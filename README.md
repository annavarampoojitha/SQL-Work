# SQL-WORK

# SQL DDL & DML COMMANDS

show databases;

use excelr;

show tables;

Select * from students1;

Desc Students2_BKP;

DROP TABLE STUDENTS2_BKP;

CREATE TABLE STUDENTS2

(   ID             VARCHAR(20)  -- EITHER AUTO INCREMENT OR DEFAULT SHOULD USE

  , FIRST_NAME     VARCHAR(100) 
  
  , LAST_NAME      VARCHAR(100) NOT NULL  -- PREFERABLE WAY to use NOT NULL
  
  , GENDER         VARCHAR(10) CHECK (GENDER IN ('M', 'F', 'Male', 'Female'))
  
  , AGE            INT
  
  , DOB            DATE
  
  , GRADE          FLOAT
  
  , IS_ACTIVE      BOOLEAN
  
  , CONSTRAINT CH_STUDENTS10_AGE CHECK (AGE > 0)
  
  , CONSTRAINT PK_STUDENTS PRIMARY KEY (ID, FIRST_NAME)  -- 2 PRIMIARY KEY COLUMNS (only UNIQUE, PRIMARY KEY, FOREIGN KEY & CHECK can use in this way)
  
  -- , constraint NN_STUDENTS NOT NULL()  -- can't use NOT NULL LIKE THIS -- NOT NULL IS NOT A CONSTRAINT
  
  -- , CONSTRAINT AI_STUDENTS10 AUTO INCREMENT(ID)  -- AUTO INCREMENT IS NOT A CONSTRAINT

);

CREATE TABLE STUDENTS2_BKP AS SELECT * FROM STUDENTS1;

SELECT * FROM STUDENTS2;

SELECT * FROM STUDENTS2_BKP;


create table products1(

 product_code int auto_increment, 

 product_name varchar(50),

 price float,

 Released_date date,

 constraint pk_prod primary key(product_code)

);

-- insert into products (product_code, product_name, price, released_date) values (default, ' iPhone 15', 999.5, to_date('22-08-2023',Â 'dd-mm-yyyy'))ï¼›

-- SQL SERVER

-- CREATE TABLE products (

--   product_code INT IDENTITY(1,1),

--   product_name VARCHAR(50),

--   price FLOAT,

--   released_date DATE,

--   CONSTRAINT pk_prod PRIMARY KEY (product_code));


-- Insert Data (without specifying product_code)

-- INSERT INTO products (product_name, price, released_date) VALUES ('iPhone 15', 999.5, '2023-08-22');

-- POSTGREY SQL

-- CREATE TABLE products (

--    product_code INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

--    product_name VARCHAR(50),

--    price FLOAT,

--    released_date DATE);

-- Insert Data (with DEFAULT allowed for identity)

-- INSERT INTO products (product_code, product_name, price, released_date) VALUES (DEFAULT, 'iPhone 15', 999.5, '2023-08-22');

-- ORACLE

-- CREATE TABLE products (

--    product_code NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

--    product_name VARCHAR2(50),

--    price FLOAT,

--    released_date DATE);


-- Insert Data (Oracle supports TO_DATE())

-- INSERT INTO products (product_name, price, released_date) VALUES ('iPhone 15', 999.5, TO_DATE('22-08-2023', 'DD-MM-YYYY'));


-- Database	     Auto Increment Keyword

-- SQL Server	  IDENTITY

-- MySQL	      AUTO_INCREMENT

-- PostgreSQL	  SERIAL or GENERATED ALWAYS AS IDENTITY

-- Oracle	      GENERATED BY DEFAULT AS IDENTITY

         
--- DIFFERENT WAYS OF USING ALTER

Alter table students2 drop column grade;

Alter table students2 add column grade float;

Alter table students2 rename column grade to grades;

Alter table students2 modify column grades int;    

Alter table studentS2 add constraint unique_std1 unique(LAST_NAME);

Alter table students2 DROP constraint unique_std1;

Alter table students2 rename to students1;

ALTER TABLE students1 MODIFY COLUMN grades FLOAT DEFAULT 0;

ALTER TABLE students1 ALTER COLUMN grades SET DEFAULT 1;    


Desc Students2;


-- ALTER TABLE students2 ADD CONSTRAINT DF_Students2_Grade DEFAULT(grade);   -- This is only supported in SQL SERVER
-- Alter table students2 alter column grades TYPE float;  -- This is only supported in POSTGREY SQL


-- DIFFERENT WAYS OF USING INSERT

-- 1

INSERT INTO STUDENTS1

VALUES ('STD10252','Effie','Emlyn','Female',8,'2012-03-28', TRUE, 3); -- Do not mention column names.

-- 2

INSERT INTO STUDENTS1 (ID, FIRST_NAME, LAST_NAME, GENDER, AGE, DOB, GRADES, IS_ACTIVE)

VALUES ('STD10251','Minnaminnie','Cleft','Female',8,STR_TO_DATE('2012-02-23', '%Y-%m-%d'), TRUE, 3); -- Mention the column names.

-- 3

INSERT INTO STUDENTS1 VALUES

	('STD10253','Kerry','Aysik','Female',8,STR_TO_DATE('2012-01-09', '%Y-%m-%d'), TRUE, 3),
        
	('STD10254','Jo','Mansfield','Male',8,STR_TO_DATE('2012-03-26', '%Y-%m-%d'), TRUE, 3),
        
	('STD10255','Elianore','Macon','Female',8,STR_TO_DATE('2012-04-01', '%Y-%m-%d'), FALSE, 3); -- Insert multiple records.

	
-- 
INSERT INTO STUDENTS1

VALUES ('STD10152','KAJOL','AGARWAL','Female',8,str_to_date('2012-10-28', '%Y-%m-%d'), TRUE, 3);

select * from STUDENTS1;

TRUNCATE TABLE STUDENTS2_BKP;


-- 4 

INSERT INTO STUDENTS2_BKP SELECT * FROM STUDENTS1;

SELECT * FROM STUDENTS1;

DESC STUDENTS1;

DESC STUDENTS2_BKP;


-- 5

INSERT INTO STUDENTS1 (ID, FIRST_NAME, LAST_NAME, GENDER, AGE, DOB, GRADES, IS_ACTIVE)

VALUES('STD10252','Effie','Emlyn','Female',8,'2012-03-28', 4, FALSE)

AS NEW ON DUPLICATE KEY UPDATE

    GRADES= NEW.GRADES,
    
    IS_ACTIVE= NEW.IS_ACTIVE;                 -- THIS IS USED WHEN THERE IS A DUPLICATE ENTRY BUT WE NEED TO CHANGE SPECIFIC COLUMNS IN THAT PREVIOUS DATA



-- 6

-- INSERT INTO STUDENTS2_BKP DEFAULT VALUES;   -- SUPPORTED IN SQL SERVER & POSTEGREY SQL



-- DIIFERENT WAYS OF USING UPDATE

-- 1

UPDATE STUDENTS1 SET FIRST_NAME = 'James' WHERE   ID = 'STD10253'; -- Update single column.


-- 2

UPDATE STUDENTS1 SET FIRST_NAME = 'Rohan', GRADES = 4 WHERE   ID = 'STD10251'; -- Update multiple columns at once.


-- 3

-- UPDATE with Subquery (Using Data from Another Table)

UPDATE students s

SET grade = (

    SELECT avg_grade
    
    FROM student_grades sg
    
    WHERE s.id = sg.student_id

)

WHERE s.id = 'STD10252';         -- This fetches avg_grade from student_grades and updates it in students


-- 4

-- UPDATE with JOIN (Update Based on Another Table)

UPDATE students s

JOIN student_grades sg

ON s.id = sg.student_id

SET s.grade = sg.avg_grade

WHERE s.age > 10;      -- Updates grade by joining with another table.



-- 5

-- UPDATE with ORDER BY and LIMIT (MySQL-specific)

UPDATE students

SET age = age + 1

ORDER BY dob ASC

LIMIT 5;            -- This will update only the first 5 rows ordered by dob.


-- 6

-- UPDATE Using Case/Conditional Logic (Column-specific Conditions)

UPDATE students

SET grade = 

    CASE 
    
	WHEN age <= 10 THEN 5.0
        
	WHEN age <= 15 THEN 4.0
        
	ELSE 3.0
    
    END
    
WHERE gender = 'Female';         -- Different values for grade depending on age.



-- 7

-- UPDATE ALL Rows (Dangerous if Unintentional)

UPDATE students

SET grade = 3.0;     -- All rows get grade = 3.0. , Use this carefully!




-- 8

-- UPDATE Using User Variables (MySQL)

SET @new_grade = 4.5;

UPDATE students

SET grade = @new_grade

WHERE id = 'STD10252';   -- Using a variable for the value.


-- 9

-- PDATE with a Common Table Expression (CTE) - Supported in SQL Server, PostgreSQL, etc.

-- WITH ranked_students AS (

--   SELECT id, grade, ROW_NUMBER() OVER (ORDER BY grade DESC) AS rank

--    FROM students)

-- UPDATE students

-- SET grade = grade + 1

-- WHERE id IN (SELECT id FROM ranked_students WHERE rank <= 5);     -- Updates only the top 5 students by grade ( NOT ALLOWED IN MYSQL).


-- DIFFEREBT WAYS OF USING DELETE

-- 1

-- Basic DELETE (Single Condition)

DELETE FROM students WHERE id = 'STD10252';   -- Deletes a single row where id matches.


-- 2

-- DELETE All Rows (Full Table Delete)

DELETE FROM students;         -- Deletes ALL rows in the table.


-- 3

-- DELETE with Multiple Conditions

DELETE FROM students WHERE age < 5 AND gender = 'Female';      -- Deletes all rows where both conditions are true.


-- 4

-- DELETE with Subquery (Delete Based on Data in Another Table)

DELETE FROM students

WHERE id IN (

    SELECT student_id
    
    FROM student_archive
    
    WHERE archive_date < '2020-01-01');                                                  -- Deletes rows where id exists in a subquery.


-- 5

-- DELETE with JOIN (MySQL & SQL Server)

DELETE s

FROM students s

JOIN student_archive sa

ON s.id = sa.student_id

WHERE sa.archive_date < '2020-01-01';                -- Deletes rows from students that match student_archive.





-- 6

-- DELETE with LIMIT (MySQL-specific)

DELETE FROM students WHERE age < 5 ORDER BY dob ASC LIMIT 10;         -- Deletes up to 10 rows matching the condition.



-- 7

-- DELETE with EXISTS Clause

DELETE FROM students s

WHERE EXISTS (

    SELECT 1
    
    FROM student_archive sa
    
    WHERE s.id = sa.student_id

);                                       -- Deletes rows if they exist in another table.


-- 8

-- DELETE with Common Table Expression (CTE) (SQL Server, PostgreSQL)

WITH old_students AS (

    SELECT id FROM students WHERE age > 50

)

DELETE FROM students

WHERE id IN (SELECT id FROM old_students);       -- Deletes old students using a CTE.


-- 9


-- DELETE Using ORDER BY (PostgreSQL & MySQL)

DELETE FROM students

ORDER BY dob ASC

LIMIT 5;                     -- Deletes the oldest 5 students.


-- 10

-- DELETE with RETURNING (PostgreSQL & Oracle)

-- DELETE FROM students WHERE age < 5 RETURNING id, first_name, age;      -- Deletes rows and returns the deleted rows' data (works in PostgreSQL & Oracle).



-- DIFFERENT WAYS OF USING TRUNCATE

-- âš¡ Much faster than DELETE for full table deletion.

-- âš ï¸ Cannot use WHERE clause â€” it removes all rows.

-- ðŸ†“ In most databases, TRUNCATE also releases the storage space used by the table.

-- ðŸ”„ In MySQL, it resets AUTO_INCREMENT values. Use DELETE if DO NOT RESET AUTO INCREMENT.

-- âŒ Cannot be rolled back in MySQL (unless using transactions in some storage engines like InnoDB).



-- 1

-- Basic TRUNCATE (Delete All Rows)

TRUNCATE TABLE students;            -- Removes all rows from students table.



-- 2

-- TRUNCATE with CASCADE (PostgreSQL)

-- TRUNCATE TABLE students CASCADE;         -- This removes all rows from students and related child tables with foreign key constraints.



-- 3

-- TRUNCATE Multiple Tables at Once (PostgreSQL)

-- TRUNCATE TABLE students, courses, enrollments;       -- Truncates multiple tables in one command.


-- 4

-- TRUNCATE with RESTART IDENTITY (PostgreSQL)

-- TRUNCATE TABLE students RESTART IDENTITY;           -- Removes all rows and resets all sequences linked to the table columns (like SERIAL columns).


-- 6

-- TRUNCATE with Commit Implications

-- In MySQL with InnoDB, TRUNCATE is implicitly committed.

-- In PostgreSQL, if inside a transaction, TRUNCATE can be rolled back.


-- DIFFERENT WAYS OF USING DROP
 
-- The DROP command in MySQL is used to permanently delete database objects like tables, databases, views, triggers, stored procedures, functions, etc.

-- It is a destructive operation â€” once you DROP something, you can't recover it unless you have a backup.

                
DROP TABLE students;

DROP TABLE IF EXISTS students;

DROP DATABASE school_db;

DROP DATABASE IF EXISTS school_db;

DROP VIEW student_view;

DROP VIEW IF EXISTS student_view;

DROP PROCEDURE my_procedure;

DROP PROCEDURE IF EXISTS my_procedure;

DROP FUNCTION calculate_grade;

DROP FUNCTION IF EXISTS calculate_grade;

DROP TRIGGER before_student_insert;

DROP TRIGGER IF EXISTS before_student_insert;

DROP INDEX idx_student_name ON students;

DROP EVENT daily_cleanup;

DROP EVENT IF EXISTS daily_cleanup;



-- DROP is permanent (no rollback).

-- If foreign keys reference a table, DROP TABLE may fail (InnoDB).

-- Always check for IF EXISTS to avoid errors in scripts.



SET SQL_SAFE_UPDATES=0;

/* SQL_SAFE_UPDATES is a MySQL system variable that prevents accidental updates or deletes without a WHERE clause or a LIMIT clause in safe mode.

By default, in MySQL Workbench or when connected in "safe mode", this variable is set to 1 (enabled).

This means you cannot run UPDATE or DELETE queries unless they have either:

A WHERE clause (which limits the rows to be affected), OR

A LIMIT clause (which limits the number of rows affected)         */

/*       Be Careful!

Disabling SQL_SAFE_UPDATES is risky in production environments because it:

Allows accidental full table updates.

Allows accidental full table deletions.

You might unintentionally wipe out critical data.       */


/*     Good Practice

Temporarily disable SQL_SAFE_UPDATES for the session only.

Re-enable it after your operation.

-- Disable safe updates

SET SQL_SAFE_UPDATES=0;

-- Run your risky update

UPDATE students SET age = 10;

-- Re-enable safe updates (good habit after your changes)

SET SQL_SAFE_UPDATES=1;             */


# SQL TCL & DQL COMMANDS

create table student_details(name varchar(10), id int primary key);         -- 1
                            
			    
insert into student_details values("kamal", 1),("rohit",2), ("ajay",3);     -- 2

	      

select * from student_details;                           -- 3

start transaction;                                       -- 4    -- transaction will be start from here

insert into student_details values("karhtik",4);         -- 5    -- name is not entered correct, so to get previous values    

rollback;                                                -- 6    -- here karhtik data deleted by use rollback     

select * from student_details;                           -- 7

insert into student_details values("karthik",4);         -- 8  

rollback;                                                -- 9    -- here karthik will not be deleted because we already use rollback.

		                                                 -- if we again want to use rollback we have to again use start transaction 

select * from student_details;                           -- 10   -- here the values didnot rollback, once we use commit-> the values will be saved permanantly


start transaction;                                       -- 11

insert into student_details values("mounika",5);         -- 12

select * from student_details;                           -- 13 

rollback;                                                -- 14  

select * from student_details;                           -- 15   -- here the mounika details will be deleted because we again start the transaction



start transaction;                                       -- 16   

insert into student_details values("mounika",5);         -- 17

commit;                                                  -- 18

rollback;                                                -- 19

select * from student_details;                           -- 20   -- here the details will not rollback because we use commit

start transaction;                                       -- 21

rollback;                                                -- 22

select * from student_details;                           -- 23   -- once we use commit the data under that transaction can't be rollbacked, instead we can delete


delete from student_details where name="mounika";        -- 24

select * from student_details;                           -- 25   -- mounika details deleted

rollback;                                                -- 26   -- here rollback did not work cause we didnot start transaction

select * from student_details;                           -- 27 


start transaction;                                       -- 28

insert into student_details values("poojitha",6);        -- 29

delete from student_details where name="poojitha";       -- 30  

rollback;                                                -- 31

select * from student_details;                           -- 32   -- using rollback everything under that particular transaction will be rollbacked


start transaction;                                       -- 33

select * from student_details;                           -- 34

insert into student_details values("swapna",7);          -- 35

savepoint swapna;                                        -- 36   -- creating 1st savepoint

insert into student_details values("rasi",8);            -- 37  

savepoint rasi;                                          -- 38    -- creating 2nd savepoint

SET SQL_SAFE_UPDATES=0;                                  

delete from student_details where name="rohit";          -- 39

select * from student_details;                           -- 40

rollback to swapna;                                      -- 41    -- using rollback with savepoint the queries below that savepoint will be rollbacked

select * from student_details;                           -- 42 

rollback;                                                -- 43     -- if we use rollback with savepoint, then we can use rollback even without starting transaction

select * from student_details;                           -- 44     -- here using rollback all the queries mentioned under the transaction will be rollbacked


drop table student_details;                              -- 45


-- using AUTOCOMMIT

-- CASE-1

start transaction;

create table student_details_bkp1 as select * from student_details;

select * from student_details_bkp1;

set autocommit = on;

delete from student_details_bkp1;

select * from student_details_bkp1;

rollback;                                    -- KEEPING AUTOCOMMIT ON EVEN IF WE USE ROLLBACK IT WON'T WORK

select * from student_details_bkp1;

drop table student_details_bkp1;



-- CASE-2

start transaction;

create table student_details_bkp2 as select * from student_details;

select * from student_details_bkp2;

set autocommit = off;

delete from student_details_bkp2;

select * from student_details_bkp2;

commit;

rollback;                                    -- KEEPING AUTOCOMMIT OFF AND USING COMMIT THEN EVEN IF WE USE ROLLBACK IT WON'T WORK

select * from student_details_bkp2;

drop table student_details_bkp2;



-- CASE-3

start transaction;

create table student_details_bkp3 as select * from student_details;

select * from student_details_bkp3;

set autocommit = off;

delete from student_details_bkp3;

select * from student_details_bkp3;

rollback;                                    -- KEEPING AUTOCOMMIT OFF , IF WE USE ROLLBACK IT WILL WORK 

select * from student_details_bkp3;

drop table student_details_bkp3;



-- DIFFERENT WAYS OF USING SELECT


CREATE TABLE students (

    id INT AUTO_INCREMENT PRIMARY KEY,
    
    first_name VARCHAR(50),
    
    last_name VARCHAR(50),
    
    gender VARCHAR(10),
    
    age INT,
    
    course VARCHAR(50),
    
    marks FLOAT);


INSERT INTO students (first_name, last_name, gender, age, course, marks) VALUES 

('Aarav', 'Sharma', 'Male', 21, 'Computer Science', 85.5),

('Isha', 'Verma', 'Female', 22, 'Data Science', 78.0),

('Raj', 'Patel', 'Male', 20, 'Business Analytics', 74.2),

('Priya', 'Nair', 'Female', 23, 'Computer Science', 88.9),

('Karan', 'Singh', 'Male', 22, 'Mechanical Engineering', 67.5),

('Meera', 'Rao', 'Female', 21, 'Mathematics', 92.0),

('Arjun', 'Kumar', 'Male', 24, 'Economics', 71.8),

('Sanya', 'Gupta', 'Female', 20, 'Physics', 83.4),

('Vikas', 'Yadav', 'Male', 22, 'Electrical Engineering', 69.7),

('Ananya', 'Joshi', 'Female', 23, 'Data Science', 81.5);


CREATE TABLE courses (

    course_id INT AUTO_INCREMENT PRIMARY KEY,
    
    course_name VARCHAR(100) NOT NULL,
    
    department VARCHAR(50),
    
    duration INT CHECK (duration > 0), -- Duration in months
    
    fee DECIMAL(10,2) CHECK (fee >= 0) -- Course fee);


INSERT INTO courses (course_name, department, duration, fee) VALUES

('Computer Science', 'Engineering', 48, 50000.00),

('Data Science', 'IT & Analytics', 24, 60000.00),

('Business Analytics', 'Business', 18, 55000.00),

('Mechanical Engineering', 'Engineering', 48, 52000.00),

('Mathematics', 'Science', 36, 40000.00),

('Economics', 'Social Science', 36, 45000.00),

('Physics', 'Science', 36, 42000.00),

('Electrical Engineering', 'Engineering', 48, 53000.00),

('Artificial Intelligence', 'IT & Analytics', 24, 70000.00),

('Cyber Security', 'IT & Analytics', 24, 65000.00);

START TRANSACTION;

ALTER TABLE students 

ADD COLUMN course_id INT;

ALTER TABLE students

ADD CONSTRAINT fk_students_course

FOREIGN KEY (course_id)

REFERENCES courses(course_id);


UPDATE students s

JOIN courses c 

ON s.course = c.course_name

SET s.course_id = c.course_id;

DESC STUDENTS;

SELECT * FROM STUDENTS;

SELECT * FROM COURSES;

SELECT * FROM students;                                  -- 1

SELECT first_name, age FROM students;                    -- 2  

SELECT * FROM students WHERE age > 18;                   -- 3

SELECT COUNT(*) AS total_students FROM students;         -- 4

SELECT first_name, age FROM students ORDER BY age DESC;  -- 5 

SELECT DISTINCT gender FROM students;                    -- 6

SELECT * FROM students LIMIT 5;                          -- 7


SELECT s.id, s.first_name, c.course_name

FROM students s

JOIN courses c ON s.course_id = c.course_id;             -- 8


SELECT s.id, s.first_name, c.course_name

FROM students s, courses c 

WHERE s.course_id = c.course_id;                         -- 9

SELECT gender, COUNT(*) AS count_per_gender

FROM students

GROUP BY gender;                                         -- 10   

SELECT first_name, age

FROM students

WHERE age = (SELECT MAX(age) FROM students);             -- 11

SELECT first_name, 

       age, 
       
       CASE 
       
	   WHEN age < 18 THEN 'Minor'
           
	   
    
    ELSE 'Adult'
    
       END AS age_group

FROM students;                                           -- 12 


CREATE TABLE adult_students AS

SELECT * FROM students WHERE age >= 18;                  -- 13

SELECT * FROM ADULT_STUDENTS;

SELECT first_name AS name, age AS student_age FROM students;  -- 14


# SQL JOINS


-- JOINS ----

-- LEFT JOIN

SELECT s.id, s.first_name, c.course_name

FROM students s

LEFT JOIN courses c ON s.course_id = c.course_id;

-- RIGHT JOIN

SELECT s.id, s.first_name, c.course_name

FROM students s

RIGHT JOIN courses c ON s.course_id = c.course_id;

-- FULL OUTER JOIN/FULL JOIN ------->  LEFT JOIN + UNION + RIGHT JOIN

-- WHILE USING UNOION/ UNION ALL NO. OF COLUMNS AND DATA TYPE OF 2 QUERIES SHOULD BE SAME


SELECT s.id, s.first_name, c.course_name

FROM students s

LEFT JOIN courses c ON s.course_id = c.course_id

UNION

SELECT s.id, s.first_name, c.course_name

FROM students s

RIGHT JOIN courses c ON s.course_id = c.course_id;


-- FULL OUTER JOIN/FULL JOIN ------->  LEFT JOIN + UNION ALL + RIGHT JOIN

SELECT s.id, s.first_name, c.course_name

FROM students s

LEFT JOIN courses c ON s.course_id = c.course_id

UNION ALL

SELECT s.id, s.first_name, c.course_name

FROM students s

RIGHT JOIN courses c ON s.course_id = c.course_id;


-- CROSS JOIN

SELECT s.id, s.first_name, c.course_name

FROM students s

CROSS JOIN courses c ON s.course_id = c.course_id;



# SQL SUBQUERIES

CREATE TABLE FHPL_employees (

    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    
    emp_name VARCHAR(50),
    
    department VARCHAR(50),
    
    salary DECIMAL(10, 2));

Desc FHPL_employees;


select * from FHPL_employees;

INSERT INTO FHPL_employees (emp_name, department, salary) VALUES

('John Doe', 'IT', 60000.00),

('Jane Smith', 'HR', 55000.00),

('Michael Johnson', 'Finance', 70000.00),

('Emily Davis', 'Marketing', 52000.00),

('Robert Brown', 'IT', 65000.00),

('Linda Wilson', 'HR', 58000.00),

('David Miller', 'Finance', 72000.00),

('Sarah Taylor', 'Marketing', 51000.00),

('James Anderson', 'IT', 67000.00),

('Patricia Thomas', 'HR', 59000.00);


CREATE TABLE departments (

    department_id INT PRIMARY KEY AUTO_INCREMENT,
    
    department_name VARCHAR(50) UNIQUE NOT NULL);


INSERT INTO departments (department_name) 

VALUES 

('IT'),

('HR'),

('Finance'),

('Marketing'),

('Operations'),

('Data Analytics'),

('Customer Support'),

('Legal'),

('Research & Development'),

('Procurement');

SELECT * FROM DEPARTMENTS;

-- SCALAR SUQUERY

-- RETURNS SINGLE ROW AS OUTPUT (INNER QUERY)

-- SUBQUERY IN WHERE CLAUSE

-- FIND THE SALARY OF THE EMPLOYEES WHOSE SALARY IS GREATER THAN THE AVERAGE SALARY OF ALL THE EMPLOYEES


select avg(salary) from FHPL_employees;   -- 60900.000000

select * from FHPL_employees where salary > (select avg(salary) from FHPL_employees);


-- SUBQUERY IN JOIN CLAUSE

select e.* from FHPL_employees e join (select avg(salary) as sal from FHPL_employees) avg_sal on e.salary > avg_sal.sal;

select department,max(salary) from FHPL_employees group by department;

-- MULTIPLE ROW SUBQUERY

-- SUBQUERY WHICH RETURNS MULTIPLE COLUMN MULTIPLE ROW 

/* find the employees who earn the highest salary in each deparment */


select * from FHPL_employees where (department,salary) in (select department,max(salary) from FHPL_employees group by department); 

-- SUBQUERY WHICH RETURNS SINGLE COLUMN MULTIPLE ROW 

/* FIND DEPARTMENT WHO DONOT HAVE ANY EMPLOYEES */

SELECT  * FROM DEPARTMENTS WHERE DEPARTMENT_NAME NOT IN (SELECT DISTINCT DEPARTMENT FROM FHPL_EMPLOYEES);


-- CORRELATED SUBQUERY

-- A Subquery which is related to the outer query

-- find the employees in each deparment who earn more than the average salary in that department

select department, avg(salary) from FHPL_employees group by department; 

select * from FHPL_employees e1 

	 where salary > (select avg(salary) from FHPL_employees e2 where e2.department=e1.department); 

select avg(salary) from FHPL_employees where department="Marketing";

-- find department who do not have any employees

select * from departments d
      
      where not exists (select 1 from FHPL_employees e where e.department=d.department_name);

-- not exists is used whenever we need to check if a record exists in one table or the other table or if the record is not exist.

-- SUBQUERY inside a SUBQUERY (NESTED SUBQUERY)

CREATE TABLE sales1 (

    store_id INT,
    
    store_name VARCHAR(50),
    
    product_name VARCHAR(50),
    
    quantity INT,
    
    price DECIMAL(10,2)); 


INSERT INTO sales1 (store_id, store_name, product_name, quantity, price) VALUES

(1, 'Store A', 'Product X', 10, 500.00),

(2, 'Store A', 'Product Y', 5, 300.00),

(3, 'Store B', 'Product Z', 8, 200.00),

(4, 'Store C', 'Product X', 15, 450.00),

(5, 'Store B', 'Product Y', 12, 350.00),

(6, 'Store A', 'Product Z', 7, 150.00),

(7, 'Store C', 'Product Y', 9, 400.00),

(8, 'Store B', 'Product X', 6, 600.00),

(9, 'Store A', 'Product X', 11, 500.00),

(10, 'Store C', 'Product Z', 4, 250.00);


select * from sales1;

-- find stores whose sales were better than the average sales across all stores

select * from

(select store_name, sum(price) as total_sales from sales1 group by store_name) sales

join

(select avg(total_sales) as sales2 from 

	 (select store_name, sum(price) as total_sales 
         
		       from sales1 group by store_name) x ) avg_sales

on sales.total_sales > avg_sales.sales2;

with sales as 

	     (select store_name, sum(price) as total_sales from sales1 group by store_name)

select * from sales

join

(select avg(total_sales) as sales2 

	 from sales x ) avg_sales
         
	    on sales.total_sales > avg_sales.sales2;



-- SELECT, FROM, WHERE, HAVING

-- USING A SUBQUERY IN SELECT CLAUSE

-- FETCH ALL EMPLOYEE DETAILS AND ADD REMARKS TO THOSE EMPLOYEES WHO EARN MORE THAN THE AVERAGE SALARY OF ALL THE EMPLOYEES

SELECT *, 

     (CASE WHEN SALARY > (SELECT AVG(SALARY)  FROM FHPL_EMPLOYEES) 
     
	       THEN 'HIGHER THAN AVERAGE'
		
   ELSE 'NULL'
   
	    END) AS REMARKS FROM FHPL_EMPLOYEES;
            
SELECT *, 

     (CASE WHEN SALARY > AVG_SAL.SAL
     
	       THEN 'HIGHER THAN AVERAGE'
		
   ELSE 'NULL'
   
	    END) AS REMARKS FROM FHPL_EMPLOYEES
            
	    CROSS JOIN (SELECT AVG(SALARY) SAL FROM FHPL_EMPLOYEES) AVG_SAL;

-- HAVING

-- FIND THE STORES WHO HAVE SOLD MORE UNITS THAN THE AVERAGE UNITS SOLD BY ALL STORES.


SELECT STORE_NAME, SUM(QUANTITY) FROM SALES1 

       GROUP BY STORE_NAME HAVING SUM(QUANTITY) > (SELECT AVG(QUANTITY) FROM SALES1);




















        
        






